bugs:
1. handle object list in the fields that relay on other fields 
2. validate the fields name (if other instance have the same name we need to check the right instance)


file path of the call , project 
 refactored class

3. if the name of the refactored class was instanced then 
update argument 
update usage

update argument 
1. instance args 
2. newClassInfo for updating common argument 
      let instance = new className(arg1,arg2,arg3,arg4) 
      =>
      let instance = new className(new newClassInfo(arg1,arg2,arg3),arg4) 

update usage
1. store the new instance name
2. if it used use processExpression or updateWithGetter





where can the field call happened in other files?
1. in class variables
2. in constructor
3. in methods parameter
4. in method body


1. make more test
3. handle FieldClumps calls

4. Refactoring up to user (the method choice)
   for the user choice will be new class created and then refactor it first then the rest of the group
   else should be the least parameter method

5. code Optimierung 
6. unit test
7. docs

8. handle inheritance
9. handle interfaces
10. handle intersect
11. acceptance Criteria

11. report
12. gui

current issues:
handling interfaces if the methode implement interfaces do somthing
handling inheritance : Similar Methods in Parent/Child Classes:
If there are methods with similar parameters in parent and child classes (in case of inheritance),
the code should handle in these cases correctly.
